# 解题方法

## 递归

理解这段代码的执行过程需要考虑递归的特性。我们可以通过一个简单的例子来演示 `mergeTwoLists` 方法的调用过程。假设有两个有序链表：

```plaintext
l1: 1 -> 3 -> 5
l2: 2 -> 4 -> 6
```

现在我们将调用 `mergeTwoLists(l1, l2)`。

1. **初始调用**：

   - `l1` 不为空，`l2` 不为空，因此我们进入 `if l1.val <= l2.val` 分支。
   - `l1` 当前节点的值（1）小于等于 `l2` 当前节点的值（2），所以我们进入这个分支。
   - 接着调用 `l1.next = self.mergeTwoLists(l1.next, l2)`，这里就开始了递归。

2. **第一层递归**：

   - 新的调用 `mergeTwoLists(l1.next, l2)`。
   - `l1` 现在是 `1 -> 3 -> 5`，`l2` 保持不变。
   - 重复上述步骤。这一层递归中，`l1` 当前节点的值（3）大于 `l2` 当前节点的值（2），所以我们进入 `else` 分支，调用 `l2.next = self.mergeTwoLists(l1, l2.next)`。

3. **第二层递归**：

   - 新的调用 `mergeTwoLists(l1, l2.next)`。
   - `l1` 仍然是 `1 -> 3 -> 5`，`l2` 现在是 `4 -> 6`。
   - 继续递归。在这一层中，`l1` 当前节点的值（1）小于等于 `l2` 当前节点的值（4），所以我们进入 `if` 分支，调用 `l1.next = self.mergeTwoLists(l1.next, l2)`。

4. **第三层递归**：

   - 新的调用 `mergeTwoLists(l1.next, l2)`。
   - `l1` 变为 `3 -> 5`，`l2` 保持不变。
   - 继续递归。在这一层中，`l1` 当前节点的值（3）小于等于 `l2` 当前节点的值（4），所以我们进入 `if` 分支，调用 `l1.next = self.mergeTwoLists(l1.next, l2)`。

5. **第四层递归**：

   - 新的调用 `mergeTwoLists(l1.next, l2)`。
   - `l1` 变为 `5`，`l2` 保持不变。
   - 继续递归。在这一层中，`l1` 当前节点的值（5）大于 `l2` 当前节点的值（4），所以我们进入 `else` 分支，调用 `l2.next = self.mergeTwoLists(l1, l2.next)`。

6. **第五层递归**：

   - 新的调用 `mergeTwoLists(l1, l2.next)`。
   - `l1` 变为 `5`，`l2` 变为 `6`。
   - 继续递归。在这一层中，`l1` 当前节点的值（5）小于等于 `l2` 当前节点的值（6），所以我们进入 `if` 分支，调用 `l1.next = self.mergeTwoLists(l1.next, l2)`。

7. **第六层递归**：

   - 新的调用 `mergeTwoLists(l1.next, l2)`。
   - `l1` 变为空，`l2` 保持不变。
   - 因为 `l1` 为空，根据基本情况，返回 `l2`。

现在我们回溯到之前的递归层级：

- 第五层递归返回的结果是 `5 -> 6`。
- 第四层递归的 `l2.next` 被设置为这个结果，所以 `l2` 变为 `4 -> (5 -> 6)`。
- 第四层递归返回的结果是 `4 -> 5 -> 6`。
- 第三层递归的 `l1.next` 被设置为这个结果，所以 `l1` 变为 `(3 -> 4 -> 5) -> 6`。
- 第三层递归返回的结果是 `3 -> 4 -> 5 -> 6`。
- 第二层递归的 `l2.next` 被设置为这个结果，所以 `l2` 变为 `2 -> (3 -> 4 -> 5 -> 6)`。
- 第二层递归返回的结果是 `2 -> 3 -> 4 -> 5 -> 6`。
- 最终，第一层递归的 `l1.next` 被设置为这个结果，所以整个过程返回的是 `1 -> 2 -> 3 -> 4 -> 5 -> 6`。

这就是整个递归过程的执行流程。